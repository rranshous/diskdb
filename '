# this is going to be the class we use to manipulate the key/value pairs

@decorator
class smart_error(object):
    def __new__(cls,error_string='Error'):
        self.error_string = error_string

    def __call__(self,f,*args,**kwargs):
        # we want to raise through BlipErrors.
        # we want to wrap all other errors in BlipErrors
        try:
            f(*args,**kwargs)
        except Exception, ex:
            if isinstance(ex,BlipError):
                raise ex
            else:
                raise BlipError(str(ex))

@decorator
class require_attribute(object):
    def __new__(cls,att):
        self.att = att

    def __call__(self,f,*args,**kwargs):
        from introspect import getargspec, formatargspec

        has_attribute = False

        if args and hasattr(args[0],self.att):

            # the first place to look is on the object
            if getattr(args[0],self.att):
                has_attribute = True

            # next, we need to look in the normal args
            arg_spec = formatargspec(getargspec(f))
            if args and self.att in arg_spec[0] and args[arg_spec[0].index(self.att)]:
                has_attribute = True

            # and lastly in the named args
            if self.att in kwargs and kwargs.get(self.att):
                has_attribute = True

        if not has_attribute:
            raise KeyError(self.att)
        else:
            return f(*args,**kwargs)

class Blip():
    def __init__(self,**kwargs):
        self.key = None
        self.value = None
        self.location = None
        self.auto_flush = True

        for k,v in **kwargs.iteritems():
            if not hasattr(self,k):
                raise KeyError(k)
            setattr(self,k,v)

    @smart_error('Error while getting value: %(err)s')
    @auto_flush
    @require_key
    def get_value(self,key=None):
        if not self.value:
            self.update_value()
        return self.value

    @smart_error('Error while setting value: %(err)s')
    @auto_flush
    @require_value # same but value
    def set_value(self):
        pass # we've already set the value in the decorator

    @smart_error('Error while incrementing value: %(err)s')
    @auto_flush
    @require_value
    def increment(self,to_add):
        try:
            self.value += to_add
        except TypeError:
            raise BlipError('Can not increment a %s value' % type(self.value))

    @smart_error('Error while flushing: %s(err)s')
    @require_value
    @require_key
    def flush(self):
        # flushing is going to populate if we have a key
        # and no value
        fh = open(utils.next_key_path(self.key),'w')
        fh.write(self.value)
        fh.close()
